package com.batch.creation;

import com.amazonaws.services.s3.AmazonS3Client;
import com.amazonaws.services.s3.AmazonS3URI;
import com.amazonaws.services.s3.model.*;
import com.batch.utils.S3FileTransferHandler;
import com.batch.utils.VariableCollections;
import com.batch.utils.sql.batch.BatchJDBCTemplate;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import org.testng.Reporter;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.*;

import static com.batch.api.common.Constants.InputConfigConstants.LATEST_MODIFIED_TIME;


/**
 * @author Rama Kalyan
 */
public class BatchCountValidator {
    static AmazonS3Client amazons3Client = new AmazonS3Client();


    public static JsonObject convertingToJsonObject(String jsonFilePath) {
        try {
            JsonObject json_object = new JsonParser().parse(jsonFilePath).getAsJsonObject();
            return json_object;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }


    }

    private static String displayTextInputStream(InputStream input) throws IOException {
        // Read the text input stream one line at a time and display each line.
        BufferedReader reader = new BufferedReader(new InputStreamReader(input));
        StringBuffer sb = new StringBuffer();
        String line;
        while ((line = reader.readLine()) != null) {
            sb.append(line);
        }
        return sb.toString();

    }

    public static List<String> getBatchManifestFileList(Integer pilotId, String component, String s3Bucket, String manifest_prefix, Timestamp batch_creation_time) {
        ListObjectsV2Request req = new ListObjectsV2Request().withBucketName(s3Bucket).withPrefix(manifest_prefix).withDelimiter("/");

        ListObjectsV2Result fileObjs = amazons3Client.listObjectsV2(req);
        List<S3ObjectSummary> summaries = fileObjs.getObjectSummaries();
        Reporter.log("previous batch Creation Time -> " + batch_creation_time, true);
        Reporter.log("Current Batch creation service also completed and verifying generated manifest files generated by this batch -> ", true);
        List<String> manifestObjs = new ArrayList<String>();
        if (batch_creation_time != null) {
            //difference between batch_creation_time in table is 1 sec delay with the actual manifest file modified time in aws s3,
            // So adding 2 sec to get rid of the reconsideration of the same batch
            batch_creation_time = Timestamp.from(batch_creation_time.toInstant().plusSeconds(2));
        }
        for (S3ObjectSummary summary : summaries) {
            if ((batch_creation_time != null && batch_creation_time.compareTo(summary.getLastModified()) <= 0)) {
                Reporter.log("Manifest Object generated -> " + summary.getKey() + " at : " + summary.getLastModified(), true);
                manifestObjs.add(summary.getKey());
            }
        }
        return manifestObjs;
    }

    public static List<String> getBatchManifestFiles(Integer pilotId, String component, String s3Bucket, String manifest_prefix) {
        ListObjectsV2Request req = new ListObjectsV2Request().withBucketName(s3Bucket).withPrefix(manifest_prefix).withDelimiter("/");
        ListObjectsV2Result fileObjs = amazons3Client.listObjectsV2(req);
        List<S3ObjectSummary> summaries = fileObjs.getObjectSummaries();
        List<String> manifestObjs = new ArrayList<String>();
        Reporter.log("In BatchCountValidator", true);
        for (S3ObjectSummary summary : summaries) {
            manifestObjs.add(summary.getKey());
        }
        return manifestObjs;
    }

    public static void getManifestFiles(Integer pilotId, String component, String s3Bucket, String manifest_prefix) {
        ListObjectsV2Request req = new ListObjectsV2Request().withBucketName(s3Bucket).withPrefix(manifest_prefix).withDelimiter("/");
        ListObjectsV2Result fileObjs = amazons3Client.listObjectsV2(req);
        List<S3ObjectSummary> summaries = fileObjs.getObjectSummaries();
        List<String> manifestObjs = new ArrayList<String>();

    }


    public static Integer getExpectedNoOfBatches(String s3Bucket, String prefix, Long dataSizeInBytes, Integer maxLookUpDays, Timestamp latest_modified_time, String directoryStructure) {

        Calendar c = Calendar.getInstance();
        Integer expectedNumberOfBatches = 0;
        long tempAccumulatedSize = 0L;






        ListObjectsV2Request ListObjreq = new ListObjectsV2Request().withBucketName(s3Bucket).withPrefix(prefix);

        String RunType = (String) VariableCollections.map.get("RunType");

        Reporter.log("Runtype : " + RunType, true);

        if (RunType.equals("InitRun") && maxLookUpDays > -1) {
            //For Initial run and where maxLookUpDays is greater than -1 then maxLookUpdays + current day will be considered for batch
            c.add(Calendar.DATE, -(maxLookUpDays + 1));
            String dt = directoryStructure.equals("PartitionByDate") ? "date=" + new SimpleDateFormat("yyyy-MM-dd").format(c.getTime()) : new SimpleDateFormat("yyyy/MM/dd").format(c.getTime());
            ListObjreq = ListObjreq.withStartAfter(dt);
        } else if (RunType.equals("SubseqRun")) {
            //For any subsequent run buffer of 2 days + current day will be considered for the batch
            c.add(Calendar.DATE, -3);
            String dt = directoryStructure.equals("PartitionByDate") ? "date=" + new SimpleDateFormat("yyyy-MM-dd").format(c.getTime()) : new SimpleDateFormat("yyyy/MM/dd").format(c.getTime());
            ListObjreq = ListObjreq.withStartAfter(dt);
        }


        ArrayList<S3ObjectSummary> summ = new ArrayList<>();
        ListObjectsV2Result objs = null;
        do {
            objs = amazons3Client.listObjectsV2(ListObjreq);
            summ.addAll(objs.getObjectSummaries());



            ListObjreq.setContinuationToken(objs.getNextContinuationToken());
        } while (objs.isTruncated());


        for (S3ObjectSummary summary : summ) {
            // below condition to be modified bit more based on the maxlookupdays logic

            if (maxLookUpDays == -1 || RunType.equals("InitRun") || (latest_modified_time.compareTo(summary.getLastModified()) < 0)) {
                Reporter.log("Object accumulated : ", true);
                Reporter.log(summary.getKey(), true);
                tempAccumulatedSize += summary.getSize();
                if (tempAccumulatedSize >= dataSizeInBytes) {
                    expectedNumberOfBatches++;
                    tempAccumulatedSize = 0;
                }
            }
        }

        if (expectedNumberOfBatches == 0) {
            Reporter.log("Configured Sized Data " + dataSizeInBytes + " hasn't been accumulated. Hence one TIME_BASED manifest batch may get generated !", true);
            expectedNumberOfBatches = 1;
        }
        return expectedNumberOfBatches;
    }

    public static Long getAccumulatedSize(Integer pilotId, String component, String s3Bucket, String prefix) {
        Map<String, Long> stats = new HashMap<>();
        long DataAccumulatedSize = 0L;
        BatchJDBCTemplate batchJDBCTemplate = new BatchJDBCTemplate();

        List<Map<String, Object>> latestObjectDetails = batchJDBCTemplate.getLatestObjectDetails(pilotId, component);
        Timestamp latest_modified_time = (Timestamp) latestObjectDetails.get(0).get(LATEST_MODIFIED_TIME);

        if (latest_modified_time == null) {
            Date now = new Date();
            Timestamp ts = new Timestamp(now.getTime());
            latest_modified_time = ts;
        }

        ListObjectsV2Request ListObjreq = new ListObjectsV2Request().withBucketName(s3Bucket);
        ArrayList<S3ObjectSummary> summ = new ArrayList<>();
        ListObjectsV2Result objs = null;
        do {
            objs = amazons3Client.listObjectsV2(ListObjreq);
            summ.addAll(objs.getObjectSummaries());
            ListObjreq.setContinuationToken(objs.getNextContinuationToken());
        } while (objs.isTruncated());


        for (S3ObjectSummary summary : summ) {
            if (latest_modified_time.compareTo(summary.getLastModified()) <= 0) {
                Reporter.log(String.valueOf(summary.getLastModified()), true);
                DataAccumulatedSize += summary.getSize();
            }
        }
        return DataAccumulatedSize;
    }


    public static long SizeOfObjects(String s3Bucket, JsonArray batchObjects) {
        long DataAccumulatedSize = 0;
        for (JsonElement arr : batchObjects) {
            Reporter.log(arr.getAsString(), true);
            AmazonS3URI batchObj = new AmazonS3URI(arr.getAsString());
            S3Object Obj = amazons3Client.getObject(batchObj.getBucket(), batchObj.getKey());
            DataAccumulatedSize += Obj.getObjectMetadata().getContentLength();

            // long ObjectLength = amazons3Client.getObject(new GetObjectRequest(batchObj.getBucket(), batchObj.getKey())).getObjectMetadata().getContentLength();
            //DataAccumulatedSize += ObjectLength;
        }
        return DataAccumulatedSize;
    }


    public static long UploadAndAccumulate(String SRC, String DEST) {
        AmazonS3URI DEST_URI = new AmazonS3URI(DEST);
        long DataAccumulatedSize = S3FileTransferHandler.TransferFiles(DEST_URI, SRC);
        return DataAccumulatedSize;
    }

    public static void delawsObjects(String bucketName, String bucketprefix) {
        if (amazons3Client.doesBucketExist(bucketName)) {
            ListObjectsRequest listObjectsRequest = new ListObjectsRequest()
                    .withBucketName(bucketName)
                    .withPrefix(bucketprefix);

            ObjectListing objectListing = amazons3Client.listObjects(listObjectsRequest);

            while (true) {
                for (S3ObjectSummary objectSummary : objectListing.getObjectSummaries()) {
                    amazons3Client.deleteObject(bucketName, objectSummary.getKey());
                    Reporter.log("Removing Old objects : " + objectSummary.getKey(), true);
                }
                if (objectListing.isTruncated()) {
                    objectListing = amazons3Client.listNextBatchOfObjects(objectListing);
                } else {
                    break;
                }
            }
        }
    }

}


